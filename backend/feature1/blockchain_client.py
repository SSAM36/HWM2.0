import json
import os
from web3 import Web3
from dotenv import load_dotenv

load_dotenv(os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env'))

# Path to the config generated by deploy.py
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "blockchain_config.json")

def get_blockchain_connection():
    """Establishes connection to the blockchain."""
    # Use generic RPC if set, else fallback to Ganache default
    rpc_url = os.getenv("BLOCKCHAIN_RPC_URL", "https://127.0.0.1:8545")
    w3 = Web3(Web3.HTTPProvider(rpc_url))
    return w3

def register_land_on_blockchain(land_data, doc_data, validation_res):
    """
    Calls the Smart Contract to register the land.
    Returns the Transaction Hash (tx_hash).
    """
    if not os.path.exists(CONFIG_PATH):
        print("‚ö†Ô∏è Blockchain config not found. Run deploy.py first!")
        return "SIMULATED_HASH_NO_CONTRACT"

    try:
        with open(CONFIG_PATH, "r") as f:
            config = json.load(f)

        w3 = get_blockchain_connection()
        if not w3.is_connected():
            print("‚ùå Could not connect to Blockchain.")
            return "CONNECTION_FAILED"

        contract_address = config["contract_address"]
        abi = config["abi"]
        # Validate Account
        sender_account = config["account"]
        if sender_account not in w3.eth.accounts:
            print(f"‚ùå Account {sender_account} not found in current Ganache session.")
            print("üí° Hint: Did you restart Ganache? Run 'python deploy.py' again to update config!")
            return "ERROR_ACCOUNT_MISMATCH"

        contract = w3.eth.contract(address=contract_address, abi=abi)

        # Prepare Data & Ensure Types
        land_id = str(land_data.get("id"))
        owner_name = str(doc_data.get("ocr_data", {}).get("owner_name", "Unknown"))
        mapped_area = int(float(land_data.get("area_sqm", 0)))
        doc_area = int(float(doc_data.get("extracted_area_sqm", 0)))
        conf_score = int(float(validation_res.get("system_confidence", 0)))
        status = str(validation_res.get("status", "PENDING"))
        ipfs_hash = "QmSimulatedIPFSHash" 

        print(f"üîó Sending Transaction... [LandID: {land_id}, Account: {sender_account}]")

        # Send Transaction
        tx_hash = contract.functions.registerLand(
            land_id,
            owner_name,
            mapped_area,
            doc_area,
            conf_score,
            status,
            ipfs_hash
        ).transact({'from': sender_account})

        # Wait for receipt
        receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        
        # Return hex string of hash
        return receipt.transactionHash.hex()

    except Exception as e:
        print(f"‚ùå Blockchain Error: {e}")
        return f"ERROR_{str(e)[:20]}"
